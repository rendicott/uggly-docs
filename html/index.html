<html>
<body>
<h1>Uggly Documentation</h1>
<ul>
<li><a href="#introduction">1 Introduction</a>
<li><a href="#why">1.1 Why</a>
<li><a href="#demo">1.2 Try A Demo</a>
<li><a href="#how-it-works">1.3 How It Works</a>
<li><a href="#how-to-build-servers">2 How to Build Servers</a>
<li><a href="#hello-world">2.1 Hello World Servers</a>
<li><a href="#server-guide">2.3 Generic Server Guide</a>
<li><a href="#how-to-host-servers">2.4 How to Host Servers</a>
</ul>
<h2 id="introduction">Introduction</h2>
<p>Uggly is a means to generate Terminal User Interfaces in a client-server architecture. Think of it as TUI over-the-wire (TUIOW). The client requests content from the server via gRPC protobuffers and the client handles rendering of that content. The server is sending "pages" of content one screen at a time. The protocol and page definitions take inspiration from CSS/HTML in that there are constructs such as DivBoxes, TextBlobs, Links, and Forms for example. It is opinionated in that only keyboard strokes are supported for link navigation.</p>

<p>There is a <a href="https://github.com/rendicott/uggly-client">client</a> compiled for Windows, Linux, and Mac. Servers can be written in any language that supports gRPC and protobuf (e.g, Go, Python, Java, etc.) and honors the <a href="https://github.com/rendicott/uggly">uggly</a> protocol. New clients could be written in other languages similar to the way that there are multiple web browsers today a la Firefox, Chrome, Edge, etc.

<table border=1 align=center>
<tr>
<td>
	<img width="45%" src="./img/windows.png"></img>
	<p>Windows Client running in Powershell terminal window connected to a python server displaying a dynamic table.</p>
</td>
<td><img width="45%" src="./img/windows2.png"></img>
	<p>Windows Client running in Powershell terminal window connected to a Golang server handling a login workflow</p>
</td>
</tr>
</table>

<h2 id="why">Why</h2>
When starting out as a developer, scripter you're usually trying to automate some mundane task. Generally you start out by writing a CLI app. CLI apps are amazing for their flexibility and speed but they're often times not as portable or have a steep learning curve for end users. For example, Think of giving your least computer savvy friend a CLI tool that does something mundane like rebooting a server and ask them to run it.</p>

<p>There is no doubt that GUI's are useful. For instance, there's no better way to interact with some systems than being able to see data in a tabular format. Today, if someone wants to write a GUI they have to use Web languages and view it in a browser or use desktop UI toolkits such as Qt, Swift, etc. Web apps are the most accessible because almost everyone already has a web browser but they're not always the best UX design and are often bloated and slow. Desktop apps are fast and highly optimized for their single-purpose (keyboard shortcuts are amazing) but less accessible because you have to download an app for every UI you want to use.</p>

<p>So if you're a developer and you're trying to share a UI with your users you're in a predicament. Do you put your time into a Web app or a Desktop app? Either of these options are non-trivial because despite their ubiquitous nature, they have steep learning curves and are often overkill for simple tasks.</p>

<p>Terminal User Interfaces have been around for a <i>long</i> time. They were quite common in the early days of desktop computing so they're nothing new or terribly novel. There's actually been a resurgence in TUI's over the past few years as people look for something simpler and more novel. The efficiencies that can be had when UI's are designed for use with a keyboard only are pretty incredible--never underestimate the power of human muscle memory. However, they're still essentially a desktop application--just like the Qt and Swift applications the users have to download the application when they want to use the UI. This makes them essentially a novelty because nobody is going to build any serious TUI because they would only have a limited number of users who would use it.</p>

<p>What if there was something that took some of the best of both worlds? The accessibility and flexibility of the browser and the efficiency of the TUI. This is what the uggly protocol is experimenting with. Offload the client side rendering of the TUI to the "browser" and let server developers focus on building "web apps" using concepts that they're familiar with (components, links, cookies, etc.). That way the end-users only have to download one client that lets them access any number of applications. Multi-platform support is built into the concept because every major operating system has a terminal.</p>

<p>There are no doubts that this will never <i>really</i> take off because right out of the gate it has no images, no mobile support and it's still highly unlikely that many people will opt to write a server-side TUI app instead of a web app. However, maybe making it a little bit easier could help make TUI's more ubiquitous. In any case, TUI's are a lot of fun to use and they can also be fun to write.</p>

<h2 id="demo">Try a Demo</h2>
<ol>
<li>Download the client for your architecture <a href="https://github.com/rendicott/uggly-client/releases/latest">here.</a>
<li>Unpack the tarball. 
<li>Then run the client in a terminal.
<ul>
	<li>For windows you can run the .exe in either CMD or Powershell.
</ul>
<li>You'll be presented with a blank screen. Try hitting (F1) and typing one of the following addresses in the address bar:
<ul>
	<li><pre> ugtps://ttt.bytester.net:443/login </pre> - This is a site that demonstrates the platform's abilities at handling sessions and cookies similar to an HTTP browser. This server is written in golang and the code for this demo can be found <a href="https://github.com/rendicott/uggly-server-login">here.</a>
	<li><pre> ugtps://ttt.bytester.net:1443/astro </pre> - This is a site that demonstrates how you can scroll through large amounts of dynamic content using keystrokes. This server is written in python and the code for the demo can be found <a href="https://github.com/rendicott/puggly-server">here.</a>
</ul>
<li>You can explore those sites and if you want you can bookmark them by hitting (F7) so you don't have to type it again.
</ol>

<h2 id="how-it-works">How it Works</h2>
<p>It's kind of like a how a browser requests a page from a web server except that it's using a different protocol than HTML. They key difference is that there is no client side code (e.g., Javascript) and each screen that a user sees is generated on-demand by the server when the client makes the request. For, example, content that exceeds the size of the client's screen should be broken up into multiple pages by the server.  Also, the server dictates what key-presses are available for link actions.</p>

<p>The below diagram may offer a better explanation:</p>
  
<pre>


                               uggly Protocol Basic Concept (pseudocode)

      Client
    ┌─────────────────────────┐                             Server
    │ (generates PageRequest) │                          ┌────────────────────────────────────────────────┐
    │ ┌─────────────────────┐ │             ┌────────────┤► (processes PageRequest                        │
    │ │PageRequest{         │ │             │            │          │          ▼                          │
    │ │ Name: home,         │ │             │            │          ▼                                     │
    │ │ Server: tui.app.com,│ │             │            │  (generates PageResponse)                      │
    │ │ Port: 8888}         │ │             │            │ ┌───────────────────────────────────────────┐  │
    │ └─────────────────────┘ │  gRPC       │            │ │PageResponse{                              │  │
    │ GetPage(PageRequest)    ├─────────────┘            │ │  Name: home,                              │  │
    └─────────────────────────┘                          │ │  DivBoxes: [div1=(x,y,height,width,color)]│  │
                                                         │ │  Elements: [                              │  │
    ┌──────────────────────────────┐      gRPC           │ │     TextBlobs: [text1, text2],            │  │
    │  (processes PageResponse) ◄──┼─────────────────────┼─┤     Forms: [form1],                       │  │
    │             │                │                     │ │  ],                                       │  │
    │             ▼                │                     │ │  KeyStrokes: [                            │  │
    │  (renders components, sets   │                     │ │     "n" => page:news,                     │  │
    │   cookies, polls for         │                     │ │     "a" => page:about,                    │  │
    │  provided keystrokes)        │                     │ │  ],                                       │  │
    │                              │                     │ │  Cookies: [theme: "dark"],                │  │
    │  ┌────────────────────────┐  │                     │ │ }                                         │  │
    │  │┼──────────────────────┼│  │                     │ └───────────────────────────────────────────┘  │
    │  ││                      ││  │                     │                                                │
    │  ││ ┌──┐ ┌───┐ ┌───────┐ ││  │                     └────────────────────────────────────────────────┘
    │  ││ └──┘ └───┘ └───────┘ ││  │
    │  ││                      ││  │
    │  │┼──────────────────────┼│  │
    │  └────────────────────────┘  │
    │                              │
    │  (key press generates new    │
    │   PageRequest, repeat        │
    │    process)                  │
    │                              │
    │                              │
    └──────────────────────────────┘
</pre>


Since there is already an existing <a href="https://github.com/rendicott/uggly-client">client</a> that you can use it may be more helpful to just talk about how one writes a server. 

<h1 id="how-to-build-servers">How to Build Servers</h1>
<p>The only way to get more great TUI's is to have more people write more of them. I tried to make authoring servers easy and it can be a lot of fun once you get into it. There's something refreshing about using simple building blocks that are easy to understand that make for a very satisfying end product. </p>
<p>If you're familiar with gRPC then building servers should be fairly straightforward. Both the Python an Go starter guides from <a href="https://grpc.io/">grpc.io</a> were used to form the base of the following sections. If you prefer to write servers in a different language then the <a href="https://github.com/rendicott/uggly">uggly protobuf</a> will be your only guide.</p>

<h2 id="hello-world">Hello-World Servers</h2>

<p>If you're just getting started I would recommend writing in Python. The flexibility makes for much easier content generation and for server side you don't have to worry about the distribution and dependency problems.</p>

<p>For Python, start with the <a href="https://github.com/rendicott/uggly/tree/master/samples/python">python sample hello world</a>.</p>

<p>For Golang, start with the <a href="https://github.com/rendicott/uggly/tree/master/samples/go">go sample hello world</a>.</p>

<h2 id="server-guide">Generic Server Guide</h2>
<p>The initial hurdle of writing uggly servers is understanding the core concepts and that is mostly language agnostic. This section will be all about understanding the basics, core design principles, and tips and tricks. </p>

<p>The heart of every server is the `GetPage` handler which accepts `PageRequest` and returns `PageResponse`. Let's take a look at an excerpt from the docs of a <a href="https://github.com/rendicott/uggly/tree/master/doc#pagerequest">`PageRequest`</a></p>

<table center=true border=1 width="50%"><tr><td>
<p>A PageRequest contains the name of the
desired page and some metadata about the
cient height and width. The server can choose
to ignore the width and height if it insists
on statically sized content. Also, the server could
generate a PageResponse saying something like
"this server insists on a minimum height to view
content" for example.</p>


<table border=1>
<thead> <tr> <th>Field</th> <th>Type</th> <th>Label</th> <th>Description</th> </tr> </thead>
<tbody>
<tr> <td>name</td> <td>string</td> <td></td> <td>The name of the page being requested</td> </tr>
<tr> <td>clientWidth</td> <td>int32</td> <td></td> <td>The width of the client at the time of the request</td> </tr>
<tr> <td>clientHeight</td> <td>int32</td> <td></td> <td>The height of the client at the time of the request</td> </tr>
<tr> <td>formData</td> <td><a href="https://github.com/rendicott/uggly/tree/master/doc#uggly-FormData">FormData</a></td> <td>repeated</td> <td>data from form submissions or could be used to send generic key value pairs</td> </tr>
<tr> <td>server</td> <td>string</td> <td></td> <td>the intended server for the request</td> </tr>
<tr> <td>port</td> <td>string</td> <td></td> <td>the intended port for the request</td> </tr>
<tr> <td>secure</td> <td>bool</td> <td></td> <td>whether or not the connection should be secure (TLS)</td> </tr>
<tr> <td>sendCookies</td> <td><a href="https://github.com/rendicott/uggly/tree/master/doc#uggly-Cookie">Cookie</a></td> <td>repeated</td> <td>Cookies that are intended to be sent from client to server</td> </tr>
<tr> <td>stream</td> <td>bool</td> <td></td> <td>whether or not the request is for a page stream</td> </tr>
</tbody>
</table>
</td></tr></table>

<h2 id="how-to-host-servers">How to Host Servers</h2>
<p>You'll need some sort of compute for hosting as there's not many ways to host a gRPC server in a "serverless" fashion. Supposedly on <a href="https://cloud.google.com/blog/products/serverless/cloud-run-now-supports-http-grpc-server-streaming">GCP you can do it with Cloud Run</a> but on traditional hosting or on AWS this means hosting on some sort of server or container. For AWS this is EC2, EKS, ECS, etc. AWS Application Load Balancers (ALB) <a href="https://aws.amazon.com/blogs/aws/new-application-load-balancer-support-for-end-to-end-http-2-and-grpc/">support gRPC</a>, so that's nice. </p>

<p>Docker is a good solution so you don't have to mess around with systemd wrappers, etc. The above demo sites (e.g., 'ugtps://ttt.bytester.net:443') are hosted on AWS ECS behind an ALB using the ECS native Blue/Green deployment with CodeDeploy. The actual hosting of the gRPC server was easy but the ECS bits with CodeDeploy were needlessly complex, IMO. Here is what the architecture looks like.</p>
<pre>

      Uggly Server Hosting on AWS ECS

                                 ┌──────────────────────────┐
                                 │ Route53                  │
                                 │                          │
                                 │  ttt.bytester.net        │
                                 └───────────┬──────────────┘
                                             │
               ┌─────────────────────────────┼──────────────────────────────┐
               │ EC2                         │                              │
               │           ┌─────────────────▼──────────────────────┐       │
               │           │ ALB                                    │       │
               │           │     SSL                     SSL        │       │
               │           │   Listener                Listener     │       │
               │           │    TCP 443                TCP 1433     │       │
               │           │                                        │       │
               │           └──┬─────────────────────────────┬───────┘       │
               │              │                             │               │
               │  ┌───────────▼────────┐         ┌──────────▼─────────┐     │
               │  │ Target Group gRPC  │         │ Target Group gRPC  │     │
               │  │                    │         │                    │     │
               │  │                    │         │                    │     │
               │  └────────┬───────────┘         └───────────┬────────┘     │
               │           │                                 │              │
               └───────────┼─────────────────────────────────┼──────────────┘
                           │                                 │
                           │                                 │
                           │                                 │
        ┌──────────────────┼─────────────────────────────────┼───────────────────┐
        │   ECS Fargate    │                                 │                   │
        │                  │                                 │                   │
        │                  │                                 │                   │
        │        ┌─────────▼────────────┐            ┌───────▼──────────────┐    │
        │        │ uggly-server-login   │            │ puggly-server        │    │
        │        │    (go container)    │            │  (python container)  │    │
        │        │      TCP 80          │            │    TCP 50051         │    │
        │        └──────────────────────┘            └──────────────────────┘    │
        │                                                                        │
        └────────────────────────────────────────────────────────────────────────┘


</pre>

</body>
</html>
